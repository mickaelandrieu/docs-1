{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nWhat is BackBee ?\n\n\nBackBee is an open source Content Management System (CMS) with one major advantage. BackBee uses On-page Editing Technology (OET) which means you can easily create and manage websites as they appear with no prior technical knowledge.\n\n\nWhat is an Open-page Editing Site?\n\n\nOn-page Editing Technology (OET) is the natural evolution of your usual Content Management System functionalities. On-page Editing Technology is a tool that allows you to enter, edit and manage your website directly as it appears to users: The back office and front office are merged.\n\n\nWhat's this means?\n\n\nIn most content management systems, you have to shuttle between the back office \u2013 a functional interface \u2013 and a \u201cpreview\u201d mode. This is the only way for you to see what users will.\n\n\nBackBee\u2019s On-Page Editing Technology lets you directly do all your inputting and editing on the page that appears to users. Therefore you get an immediate and exact idea of what the final page will look like eliminating all unnecessary operations.\n\n\nWhat\u2019s so interesting about this?\n\n\nIt's easier and more flexible than your usual CMS. With BackBee's On-page Editing Technology, you can work directly on your HTML page, the page that's visible to users. You can drag and drop page elements and move them around as you wish, adding, deleting or changing text, photos or other page elements by simply clicking on the area in question.\n\n\nThe majority of the editorial functions are present in one single compact toolbar on top of your website page. BackBee is the first CMS to use On-Page editing Technology merging back office and front office.\n\n\nKey concepts\n\n\n\n\nIt\u2019s unimaginably easy to use.\n\n\nResponsive design is native to the app.\n\n\nIt\u2019s super flexible in terms of graphic design, workflow, SEO and user access.\n\n\nIt's secure, in several senses: it saves changes so that editorial security is guaranteed; it's easy to configure user access and rights; and the BackBee core is very secure, so developers can make contributions fearlessly.\n\n\nIt\u2019s open source, which means it\u2019s constantly being tested and improved.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-is-backbee", 
            "text": "BackBee is an open source Content Management System (CMS) with one major advantage. BackBee uses On-page Editing Technology (OET) which means you can easily create and manage websites as they appear with no prior technical knowledge.  What is an Open-page Editing Site?  On-page Editing Technology (OET) is the natural evolution of your usual Content Management System functionalities. On-page Editing Technology is a tool that allows you to enter, edit and manage your website directly as it appears to users: The back office and front office are merged.  What's this means?  In most content management systems, you have to shuttle between the back office \u2013 a functional interface \u2013 and a \u201cpreview\u201d mode. This is the only way for you to see what users will.  BackBee\u2019s On-Page Editing Technology lets you directly do all your inputting and editing on the page that appears to users. Therefore you get an immediate and exact idea of what the final page will look like eliminating all unnecessary operations.  What\u2019s so interesting about this?  It's easier and more flexible than your usual CMS. With BackBee's On-page Editing Technology, you can work directly on your HTML page, the page that's visible to users. You can drag and drop page elements and move them around as you wish, adding, deleting or changing text, photos or other page elements by simply clicking on the area in question.  The majority of the editorial functions are present in one single compact toolbar on top of your website page. BackBee is the first CMS to use On-Page editing Technology merging back office and front office.", 
            "title": "What is BackBee ?"
        }, 
        {
            "location": "/#key-concepts", 
            "text": "It\u2019s unimaginably easy to use.  Responsive design is native to the app.  It\u2019s super flexible in terms of graphic design, workflow, SEO and user access.  It's secure, in several senses: it saves changes so that editorial security is guaranteed; it's easy to configure user access and rights; and the BackBee core is very secure, so developers can make contributions fearlessly.  It\u2019s open source, which means it\u2019s constantly being tested and improved.", 
            "title": "Key concepts"
        }, 
        {
            "location": "/developper-documentation/requirements/", 
            "text": "Developper documentation\n\n\nRequirements for running BackBee CMS\n\n\nTo run BackBee CMS, your system needs to fulfill to a list of requirements.\n\n\nHere you will find the list of required and optional requirements.\n\n\nRequired\n\n\nBecause BackBee CMS is built on top of Symfony components, theses elements are required.\n\n\n\n\nJSON\n needs to be enabled\n\n\nctype\n needs to be enabled\n\n\nmbstring\n needs to be enabled\n\n\nYour php configuration needs to have the date.timezone setting completed\n\n\n\n\nThe mibimum version of PHP must be: \nPHP 5.4.0\n.\n\n\nOptional\n\n\n\n\nYou (may) need to have the PHP-XML module installed\n\n\nYou (may) need to have at least version 2.6.21 of libxml\n\n\nYou (may) need to have PHP tokenizer module enabled\n\n\nYou (may) need to have iconv module enabled\n\n\nYou (may) need to have POSIX enabled (only on *nix)\n\n\nYou (may) need to have Intl installed with ICU 4+\n\n\nYou (may) need to have APC 3.0.17+ installed (or another opcode cache needs to be installed)\n\n\nphp configuration recommended settings:\n\n\n\n\nshort_open_tag = Off\n\nmagic_quotes_gpc = Off\n\nregister_globals = Off\n\nsession.auto_start = Off\n\n\n\n\nDoctrine2 (Database management)\n\n\nBecause we depend on Doctrine 2, you will need to have PDO installed. Additionally, you need to have the PDO driver installed to use your database server.\nAlso, you need \nphp5-sqlite\n extension to be installed and enabled during the installation process.", 
            "title": "Requirements"
        }, 
        {
            "location": "/developper-documentation/requirements/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/requirements/#requirements-for-running-backbee-cms", 
            "text": "To run BackBee CMS, your system needs to fulfill to a list of requirements.  Here you will find the list of required and optional requirements.  Required  Because BackBee CMS is built on top of Symfony components, theses elements are required.   JSON  needs to be enabled  ctype  needs to be enabled  mbstring  needs to be enabled  Your php configuration needs to have the date.timezone setting completed   The mibimum version of PHP must be:  PHP 5.4.0 .  Optional   You (may) need to have the PHP-XML module installed  You (may) need to have at least version 2.6.21 of libxml  You (may) need to have PHP tokenizer module enabled  You (may) need to have iconv module enabled  You (may) need to have POSIX enabled (only on *nix)  You (may) need to have Intl installed with ICU 4+  You (may) need to have APC 3.0.17+ installed (or another opcode cache needs to be installed)  php configuration recommended settings:   short_open_tag = Off\n\nmagic_quotes_gpc = Off\n\nregister_globals = Off\n\nsession.auto_start = Off  Doctrine2 (Database management)  Because we depend on Doctrine 2, you will need to have PDO installed. Additionally, you need to have the PDO driver installed to use your database server.\nAlso, you need  php5-sqlite  extension to be installed and enabled during the installation process.", 
            "title": "Requirements for running BackBee CMS"
        }, 
        {
            "location": "/developper-documentation/installation/", 
            "text": "Developper documentation\n\n\nInstallation\n\n\nMake sure you have basic knowledge of PHP5, Apache or Nginx and MySQL to install BackBee in developper mode.\n\n\nThird party Software\n\n\nFirst of all, you need to check that your computer has an appropriate working environment for web development. You need at least a web server (Apache, for instance), a database engine (MySQL, PostgreSQL, SQLite, or any PDO-compatible database engine), and \nPHP 5.4\n.\n\n\nYou need to install \ngit\n and \nComposer\n, the dependency manager for PHP.\n\n\nIf your are on Linux/Unix based (like ubuntu or Mac OS X), follow this \nlink\n for installation. Composer is also available on \nWindows system\n.\n\n\nIn a command line interface, check if \ncomposer\n is correctly installed:\n\n\n\n\nAlso, check your PHP version which should be 5.4 or more.\n\n\n\n\nSet up a domain name in your operating system.\nOn Unix/Linux based OS, you can add it into \n/etc/hosts\n file. In our example: \nblogbee.dev\n:\n\n\n127.0.0.1   blogbee.dev\n\n\n\nYou can now launch the installation process.\n\n\nWeb Installer\n\n\nOpen a command line interface and get BackBee:\n\n\n$ composer create-project \"backbee/backbee-standard\" /path/to/your/folder \"1.0\" -n\n\n\n\nThen on the \npublic\n directory, launch the builtin server of PHP:\n\n\n$ cd /path/to/your/folder/public \n php -S blogbee.dev:8000\n\n\n\nAnd you should see the first installation step of BackBee (access \nhttp://localhost:8000/install.php\n) in a web browser:\n\n\n\n\nYou need to create \ncache\n and \nlog\n folders with the correct rights, then you can refresh the page and access to the \nsecond step\n of the installer.\n\n\n\n\nIf required, check the \nrepository/Config\n folder rights and then go to the \nthird\n step.\n\n\nYou need to set your database settings. If you use a different database engine than MySQL or MariaDB, set the correct driver else you have nothing to change, only fill the fields \ndatabase name\n, \nusername\n and \npassword\n.\n\n\n\n\nYou also need to define your super admin user, fill the credentials then save and continue to the \nfourth\n step.\n\n\n\n\nBackBee Installer creates and populates the database, fill the last fields to complete the installation process: the \nsite_name\n and the \ndomain\n.\n\n\n\n\nInstallation is now completed: BackBee gives you the \nApache\n or \nNginx\n configuration you have to set up to be able to use BackBee on the chosen domain.\n\n\n\n\n\n\nWhen your web server is set up, access the site by going to \nhttp://blogbee.dev\n.\n\n\nIf everything is correctly installed, you should see the BackBee welcome message:\n\n\n\n\n\n\nIf you can't see BackBee welcome message, make sure that \ncache\n and \nlog\n folders have the correct rights. (755 or 777)\n\n\n\n\nYou can now enter your new backoffice buy pressing  \nCTRL + ALT + B\n. Fill the login dialog with the credentials you have set up in the fourth step.", 
            "title": "Installation"
        }, 
        {
            "location": "/developper-documentation/installation/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/installation/#installation", 
            "text": "Make sure you have basic knowledge of PHP5, Apache or Nginx and MySQL to install BackBee in developper mode.  Third party Software  First of all, you need to check that your computer has an appropriate working environment for web development. You need at least a web server (Apache, for instance), a database engine (MySQL, PostgreSQL, SQLite, or any PDO-compatible database engine), and  PHP 5.4 .  You need to install  git  and  Composer , the dependency manager for PHP.  If your are on Linux/Unix based (like ubuntu or Mac OS X), follow this  link  for installation. Composer is also available on  Windows system .  In a command line interface, check if  composer  is correctly installed:   Also, check your PHP version which should be 5.4 or more.   Set up a domain name in your operating system.\nOn Unix/Linux based OS, you can add it into  /etc/hosts  file. In our example:  blogbee.dev :  127.0.0.1   blogbee.dev  You can now launch the installation process.  Web Installer  Open a command line interface and get BackBee:  $ composer create-project \"backbee/backbee-standard\" /path/to/your/folder \"1.0\" -n  Then on the  public  directory, launch the builtin server of PHP:  $ cd /path/to/your/folder/public   php -S blogbee.dev:8000  And you should see the first installation step of BackBee (access  http://localhost:8000/install.php ) in a web browser:   You need to create  cache  and  log  folders with the correct rights, then you can refresh the page and access to the  second step  of the installer.   If required, check the  repository/Config  folder rights and then go to the  third  step.  You need to set your database settings. If you use a different database engine than MySQL or MariaDB, set the correct driver else you have nothing to change, only fill the fields  database name ,  username  and  password .   You also need to define your super admin user, fill the credentials then save and continue to the  fourth  step.   BackBee Installer creates and populates the database, fill the last fields to complete the installation process: the  site_name  and the  domain .   Installation is now completed: BackBee gives you the  Apache  or  Nginx  configuration you have to set up to be able to use BackBee on the chosen domain.    When your web server is set up, access the site by going to  http://blogbee.dev .  If everything is correctly installed, you should see the BackBee welcome message:    If you can't see BackBee welcome message, make sure that  cache  and  log  folders have the correct rights. (755 or 777)   You can now enter your new backoffice buy pressing   CTRL + ALT + B . Fill the login dialog with the credentials you have set up in the fourth step.", 
            "title": "Installation"
        }, 
        {
            "location": "/developper-documentation/architecture/", 
            "text": "Developper documentation\n\n\nArchitecture\n\n\nBackBee CMS relies on many Symfony components and Doctrine 2.\n\n\nHere is the list of components currently used by BackBee CMS:\n\n\n\n\nConfig\n\n\nConsole\n\n\nDebug\n\n\nDependencyInjection\n\n\nEventDispatcher\n\n\nExpression Language\n\n\nFilesystem\n\n\nHttpFoundation\n\n\nHttpKernel\n\n\nRouting\n\n\nSecurity ACL\n\n\nSecurity Core\n\n\nSecurity HTTP\n\n\nSerializer\n\n\nTranslation\n\n\nValidator\n\n\nYaml\n\n\n(Twig)\n\n\n\n\nBackBee CMS is based on a PHP application (the BackBee \"Core\") which provides a REST API managing all the contents,\nthe users, the media and the security. A REST Javascript client provides user interface.\n\n\nTo understand how BackBee CMS is built, take a look on this schema:", 
            "title": "Architecture"
        }, 
        {
            "location": "/developper-documentation/architecture/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/architecture/#architecture", 
            "text": "BackBee CMS relies on many Symfony components and Doctrine 2.  Here is the list of components currently used by BackBee CMS:   Config  Console  Debug  DependencyInjection  EventDispatcher  Expression Language  Filesystem  HttpFoundation  HttpKernel  Routing  Security ACL  Security Core  Security HTTP  Serializer  Translation  Validator  Yaml  (Twig)   BackBee CMS is based on a PHP application (the BackBee \"Core\") which provides a REST API managing all the contents,\nthe users, the media and the security. A REST Javascript client provides user interface.  To understand how BackBee CMS is built, take a look on this schema:", 
            "title": "Architecture"
        }, 
        {
            "location": "/developper-documentation/configuration/", 
            "text": "Developper documentation\n\n\nConfiguration\n\n\nBackBee CMS is powerful and highly configurable.\nIn this section, all the available configurations are broken down by the key (e.g. doctrine) that defines each possible section of your application configuration.\n\n\nBootstrap configuration (bootstrap.yml)\n\n\nThis configuration file has only two functions:\n\n\n\n\ndebug\n: set the developper mode: if \ntrue\n, the container is generated at each request.\n\n\ncontainer\n: set the container configuration which have 2 parameters\n\n\ndump_directory\n: set the location of the generated container.\n\n\nautogenerate\n: if true, the container is generated at each request.\n\n\n\n\n\n\n\n\nThe \nautogenerate\n option is useful when you want to force the generation of the container in \"production\". Don't forget this option has a performance cost.\n\n\nBundles configuration (bundles.yml)\n\n\nTo activate a bundle, you need to register it in this file:\n\n\n# /repository/Config/bundles.yml\ndemo: BackBee\\Bundle\\DemoBundle\\Demo\ntoolbar: BackBee\\Bundle\\ToolbarBundle\\Toolbar\n\n\n\n\n\nDatabase configuration (doctrine.yml)\n\n\nWe provide a demo sample configuration. You can see all available parameters into the related \nDoctrine configuration of Symfony\n:\n\n\n# /repository/Config/doctrine.yml\ndbal:\n    driver: pdo_mysql # [mysql|pgsql|sqlite]\n    host: localhost\n    port: 3306\n    dbname: backbee\n    user: root\n    password: password\n    charset: utf8\n    collation: utf8_general_ci\n    defaultTableOptions: { collate: utf8_general_ci, engine: InnoDB, charset: utf8 }\norm:\n    auto_mapping: true\n    metadata_cache_driver: apc\n    query_cache_driver:\n        type: service\n        id: my_doctrine_common_cache_service # must be a service or a FQCN\n    result_cache_driver:\n        type: memcache\n        host: localhost\n        port: 11211\n        instance_class: Memcache\n\n\n\n\n\nSEO Configuration (metadata.yml)\n\n\nThis is where you set up the HTML meta headers you want to configure for each page of BackBee:\n\n\n# /repository/Config/metadata.yml\nkeywords:\n    name: 'keywords'\n    content:\n        default: 'cms, content manager'\ndescription:\n    name: 'description'\n    content:\n        default: \nbackbee demo website\n\n    lang: 'en'\nrobots:\n    name: 'robots'\n    content:\n        default: ''\n        select: ['', 'noindex', 'nofollow', 'noindex, nofollow']\n\n\n\n\n\nThis configuration has a real impact on the toolbar, see the generated SEO form in Page context mode:\n\n\n\n\nSecurity Configuration (security.yml)\n\n\nYou can set up firewalls and sudoers inside this file. A sudoer is a super administrator:\n\n\n# /repository/Config/security.yml\nfirewalls:\n    firewall_name: { pattern: ^/, anonymous: null }\nsudoers:\n    username: userId", 
            "title": "Configuration"
        }, 
        {
            "location": "/developper-documentation/configuration/#developper-documentation", 
            "text": "", 
            "title": "Developper documentation"
        }, 
        {
            "location": "/developper-documentation/configuration/#configuration", 
            "text": "BackBee CMS is powerful and highly configurable.\nIn this section, all the available configurations are broken down by the key (e.g. doctrine) that defines each possible section of your application configuration.  Bootstrap configuration (bootstrap.yml)  This configuration file has only two functions:   debug : set the developper mode: if  true , the container is generated at each request.  container : set the container configuration which have 2 parameters  dump_directory : set the location of the generated container.  autogenerate : if true, the container is generated at each request.     The  autogenerate  option is useful when you want to force the generation of the container in \"production\". Don't forget this option has a performance cost.  Bundles configuration (bundles.yml)  To activate a bundle, you need to register it in this file:  # /repository/Config/bundles.yml\ndemo: BackBee\\Bundle\\DemoBundle\\Demo\ntoolbar: BackBee\\Bundle\\ToolbarBundle\\Toolbar  Database configuration (doctrine.yml)  We provide a demo sample configuration. You can see all available parameters into the related  Doctrine configuration of Symfony :  # /repository/Config/doctrine.yml\ndbal:\n    driver: pdo_mysql # [mysql|pgsql|sqlite]\n    host: localhost\n    port: 3306\n    dbname: backbee\n    user: root\n    password: password\n    charset: utf8\n    collation: utf8_general_ci\n    defaultTableOptions: { collate: utf8_general_ci, engine: InnoDB, charset: utf8 }\norm:\n    auto_mapping: true\n    metadata_cache_driver: apc\n    query_cache_driver:\n        type: service\n        id: my_doctrine_common_cache_service # must be a service or a FQCN\n    result_cache_driver:\n        type: memcache\n        host: localhost\n        port: 11211\n        instance_class: Memcache  SEO Configuration (metadata.yml)  This is where you set up the HTML meta headers you want to configure for each page of BackBee:  # /repository/Config/metadata.yml\nkeywords:\n    name: 'keywords'\n    content:\n        default: 'cms, content manager'\ndescription:\n    name: 'description'\n    content:\n        default:  backbee demo website \n    lang: 'en'\nrobots:\n    name: 'robots'\n    content:\n        default: ''\n        select: ['', 'noindex', 'nofollow', 'noindex, nofollow']  This configuration has a real impact on the toolbar, see the generated SEO form in Page context mode:   Security Configuration (security.yml)  You can set up firewalls and sudoers inside this file. A sudoer is a super administrator:  # /repository/Config/security.yml\nfirewalls:\n    firewall_name: { pattern: ^/, anonymous: null }\nsudoers:\n    username: userId", 
            "title": "Configuration"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_commands/", 
            "text": "CookBooks\n\n\nCreate new commands\n\n\nThe Console page of the Components section covers how to create a console application.\nThis cookbook article covers the creation of a command using BackBee Standard Edition.\n\n\nAutomatically Registering Commands\n\n\nTo make the console commands available automatically with BackBee, create a\n\nCommand\n directory inside your bundle and create a PHP file suffixed with\n\nCommand.php\n for each command that you want to provide. For example, if you\nwant to extend the DemoBundle to welcome you from the command line, create\n\nWelcomeCommand.php\n and add the following to it:\n\n\n// bundle/WelcomeBundle/Command/WelcomeCommand.php\nnamespace WelcomeBundle\\Command;\n\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n\nuse BackBee\\Console\\AbstractCommand;\n\nclass WelcomeCommand extends AbstractCommand\n{\n    protected function configure()\n    {\n        $this\n            -\nsetName('demo:welcome')\n            -\nsetDescription('Welcome someone')\n            -\naddArgument(\n                'name',\n                InputArgument::OPTIONAL,\n                'Who do you want to welcome?'\n            )\n            -\naddOption(\n                'yell',\n                null,\n                InputOption::VALUE_NONE,\n                'If set, the message will yell in uppercase letters'\n            )\n            -\nsetHelp(\nEOF\nThe \ninfo\n%command.name%\n/info\n command can welcome someone.\nWith the option ``yell``, the message will be displayed in uppercase letters.\nEOF;\n            )\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    { \n        $text = 'Welcome '.$input-\ngetArgument('name');\n\n        if ($input-\ngetOption('yell')) {\n            $text = strtoupper($text);\n        }\n\n        $output-\nwriteln($text);\n    }\n}\n\n\n\n\nThis command will now automatically be available to run:\n\n\n    $ ./backbee demo:welcome Charles", 
            "title": "Create new commands"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_commands/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_new_commands/#create-new-commands", 
            "text": "The Console page of the Components section covers how to create a console application.\nThis cookbook article covers the creation of a command using BackBee Standard Edition.  Automatically Registering Commands  To make the console commands available automatically with BackBee, create a Command  directory inside your bundle and create a PHP file suffixed with Command.php  for each command that you want to provide. For example, if you\nwant to extend the DemoBundle to welcome you from the command line, create WelcomeCommand.php  and add the following to it:  // bundle/WelcomeBundle/Command/WelcomeCommand.php\nnamespace WelcomeBundle\\Command;\n\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n\nuse BackBee\\Console\\AbstractCommand;\n\nclass WelcomeCommand extends AbstractCommand\n{\n    protected function configure()\n    {\n        $this\n            - setName('demo:welcome')\n            - setDescription('Welcome someone')\n            - addArgument(\n                'name',\n                InputArgument::OPTIONAL,\n                'Who do you want to welcome?'\n            )\n            - addOption(\n                'yell',\n                null,\n                InputOption::VALUE_NONE,\n                'If set, the message will yell in uppercase letters'\n            )\n            - setHelp( EOF\nThe  info %command.name% /info  command can welcome someone.\nWith the option ``yell``, the message will be displayed in uppercase letters.\nEOF;\n            )\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    { \n        $text = 'Welcome '.$input- getArgument('name');\n\n        if ($input- getOption('yell')) {\n            $text = strtoupper($text);\n        }\n\n        $output- writeln($text);\n    }\n}  This command will now automatically be available to run:      $ ./backbee demo:welcome Charles", 
            "title": "Create new commands"
        }, 
        {
            "location": "/developper-documentation/cookbooks/customize_error_pages/", 
            "text": "CookBooks\n\n\nCustomize error pages\n\n\nIn BackBee, thanks to Symfony Debug component all errors are treated as exceptions: pages not found or access unauthorized.\nEach error is triggered by throwing an exception in your code.\n\n\nIn \"Developper Mode\" BackBee will catch and display a \nbetter\n exception page with a lot of informations\nto help you understand the issue:\n\n\n\n\nIn production, your visitors will see the nice error page provided by BackBee:\n\n\n\n\nError pages can be customized in two different ways depending on your needs:\n\n\n\n\nIf you just want to design the contents and styles of the error pages, you can set your own error templates\n\n\nIf you need total control of exception handling to execute your own logic, create your own ExceptionListener on \nkernel.exception\n event.\n\n\n\n\nUse your own default templates\n\n\nWhen the error page loads, an internal ExceptionListener is used to render a Twig template to show template to the user.\n\n\nThis ExceptionListener uses the HTTP status code, the \ndebug\n parameter and the following logic to determine the template filename:\n\n\nBackBee provides core templates which are located into \nvendor/backbee/BackBee/Resources/layouts/error\n.\nIf the template for the code status doesn't exist, the default template which be used instead.\n\n\nIn BackBee Standard edition, theses templates are already overriden in the \nToolbarBundle\n. Theses templates are located\ninto \nvendor/backbee/toolbar-bundle/Resources/layouts/error\n folder.\n\n\nIf you want to override theses templates, your application might look like this:\n\n\nrepository/\n    Resources/\n        layouts/\n            error/\n                404.phtml\n                500.twig\n                default.phtml\n\n\n\n\nIn case you need them, the ExceptionController passes informations to the error template via the error variable.\nIt acts as the original PHP exception so you can access the HTTP status code and exception message.", 
            "title": "Customize error pages"
        }, 
        {
            "location": "/developper-documentation/cookbooks/customize_error_pages/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/customize_error_pages/#customize-error-pages", 
            "text": "In BackBee, thanks to Symfony Debug component all errors are treated as exceptions: pages not found or access unauthorized.\nEach error is triggered by throwing an exception in your code.  In \"Developper Mode\" BackBee will catch and display a  better  exception page with a lot of informations\nto help you understand the issue:   In production, your visitors will see the nice error page provided by BackBee:   Error pages can be customized in two different ways depending on your needs:   If you just want to design the contents and styles of the error pages, you can set your own error templates  If you need total control of exception handling to execute your own logic, create your own ExceptionListener on  kernel.exception  event.   Use your own default templates  When the error page loads, an internal ExceptionListener is used to render a Twig template to show template to the user.  This ExceptionListener uses the HTTP status code, the  debug  parameter and the following logic to determine the template filename:  BackBee provides core templates which are located into  vendor/backbee/BackBee/Resources/layouts/error .\nIf the template for the code status doesn't exist, the default template which be used instead.  In BackBee Standard edition, theses templates are already overriden in the  ToolbarBundle . Theses templates are located\ninto  vendor/backbee/toolbar-bundle/Resources/layouts/error  folder.  If you want to override theses templates, your application might look like this:  repository/\n    Resources/\n        layouts/\n            error/\n                404.phtml\n                500.twig\n                default.phtml  In case you need them, the ExceptionController passes informations to the error template via the error variable.\nIt acts as the original PHP exception so you can access the HTTP status code and exception message.", 
            "title": "Customize error pages"
        }, 
        {
            "location": "/developper-documentation/cookbooks/use_swift_mailer_in_backbee/", 
            "text": "CookBooks\n\n\nUse Swiftmailer in BackBee\n\n\nIntroduction\n\n\nIn BackBee there is no home made component for mailing. We actually use Swift Mailer library.\nBackBee only provides a way to configure it and get your instance initialized easily.\n\n\nConfiguration\n\n\nTo configure Swift Mailer in BackBee you need to create mailer.yml into your global configuration folder \nrepository/Config\n.\n\n\nThe minimal configuration file is composed of an SMTP and  a port\n\n\nsmtp: localhost\nport: 25\n\n\n\n\nYou can also set up more parameters for more security on SMTP.\n\n\nsmtp: localhost\nport: 587\nusername: mailer_user_identifier\npassword: superSecretPassword\n\n\n\n\nBasic usage example\n\n\nTo retrieve the configured mailer you need an access to your Application.\nYou can start with a new app, but for performances matters prefer use the current Application.\nThe example will be placed in the context of an EventListener. \nThis is not a good practice to place your business logic into an EventListener\n but it is easier to understand.\n\n\n?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Listener;\n\nuse BackBee\\Event\\Event;\nuse BackBee\\Site\\Site;\n\nclass MailerListener\n{\n    public static function onSomethingNeedToBeMailed(Event $event)\n    {\n        // retrieve your current Application\n        $application = $event-\ngetDispatcher()-\ngetApplication();\n\n        // retrieve other informations\n        $site = $application-\ngetSite();\n\n        if ($site instanceof Site) {\n            // render e-mail body by using partial method from the renderer\n            $body = $application-\ngetRenderer()-\npartial(\n                'Email/Email.twig',\n                [\n                    'site_name' =\n $site-\ngetLabel(),\n                    'home_link' =\n $site-\ngetServerName(),\n                ]\n            );\n\n            // Build the message\n            $message = static::buildMessage(\n                $body,\n                $application-\ngetSite(),\n            );\n\n            // now get the configured mailer by passing by application and send your message\n            $application-\ngetMailer()-\nsend($message);\n        }\n    }\n\n    /**\n     * E-mail message creation\n     */\n    public static function buildMessage($body, $site)\n    {\n        $from = 'administrator@' . $site-\ngetServerName();\n\n        // Create Swift_Message\n        $message = \\Swift_Message::newInstance();\n        // Set the From address\n        $message-\naddFrom($from, $site-\ngetLabel());\n        // Set the To addresses\n        $message-\naddTo($from, $site-\ngetLabel());\n        // Give the message a subject\n        $message-\nsetSubject('Something append on ' . $site-\ngetLabel());\n        // Give it the body\n        $message-\nsetBody($body, 'text/html', 'UTF-8');\n\n        return $message;\n    }\n}\n\n\n\n\nIf you want do more with Swift Mailer, you can find additional documentation on \nSwift Mailer web site", 
            "title": "Use Swift Mailer in BackBee"
        }, 
        {
            "location": "/developper-documentation/cookbooks/use_swift_mailer_in_backbee/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/use_swift_mailer_in_backbee/#use-swiftmailer-in-backbee", 
            "text": "Introduction  In BackBee there is no home made component for mailing. We actually use Swift Mailer library.\nBackBee only provides a way to configure it and get your instance initialized easily.", 
            "title": "Use Swiftmailer in BackBee"
        }, 
        {
            "location": "/developper-documentation/cookbooks/use_swift_mailer_in_backbee/#configuration", 
            "text": "To configure Swift Mailer in BackBee you need to create mailer.yml into your global configuration folder  repository/Config .  The minimal configuration file is composed of an SMTP and  a port  smtp: localhost\nport: 25  You can also set up more parameters for more security on SMTP.  smtp: localhost\nport: 587\nusername: mailer_user_identifier\npassword: superSecretPassword  Basic usage example  To retrieve the configured mailer you need an access to your Application.\nYou can start with a new app, but for performances matters prefer use the current Application.\nThe example will be placed in the context of an EventListener.  This is not a good practice to place your business logic into an EventListener  but it is easier to understand.  ?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Listener;\n\nuse BackBee\\Event\\Event;\nuse BackBee\\Site\\Site;\n\nclass MailerListener\n{\n    public static function onSomethingNeedToBeMailed(Event $event)\n    {\n        // retrieve your current Application\n        $application = $event- getDispatcher()- getApplication();\n\n        // retrieve other informations\n        $site = $application- getSite();\n\n        if ($site instanceof Site) {\n            // render e-mail body by using partial method from the renderer\n            $body = $application- getRenderer()- partial(\n                'Email/Email.twig',\n                [\n                    'site_name' =  $site- getLabel(),\n                    'home_link' =  $site- getServerName(),\n                ]\n            );\n\n            // Build the message\n            $message = static::buildMessage(\n                $body,\n                $application- getSite(),\n            );\n\n            // now get the configured mailer by passing by application and send your message\n            $application- getMailer()- send($message);\n        }\n    }\n\n    /**\n     * E-mail message creation\n     */\n    public static function buildMessage($body, $site)\n    {\n        $from = 'administrator@' . $site- getServerName();\n\n        // Create Swift_Message\n        $message = \\Swift_Message::newInstance();\n        // Set the From address\n        $message- addFrom($from, $site- getLabel());\n        // Set the To addresses\n        $message- addTo($from, $site- getLabel());\n        // Give the message a subject\n        $message- setSubject('Something append on ' . $site- getLabel());\n        // Give it the body\n        $message- setBody($body, 'text/html', 'UTF-8');\n\n        return $message;\n    }\n}  If you want do more with Swift Mailer, you can find additional documentation on  Swift Mailer web site", 
            "title": "Configuration"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_bundle_administration/", 
            "text": "CookBooks\n\n\nCreate bundle administration\n\n\nConfiguration :\n\n\nTo create an bundle administration we need to declare some parameters into the bundle configuration. Then open your config file into \nConfig/config.yml\n\n\nDefine your controller\n\n\nbundle:\n  ...\n  admin_controller:\n    doc: BackBee\\Bundle\\DocumentationBundle\\Controller\\DocController\n\n\n\n\n\n\nYou can declare controller as much as you want.\n\n\n\n\nbundle:\n  ...\n  admin_controller:\n    first: BackBee\\Bundle\\DocumentationBundle\\Controller\\FirstController\n    second: BackBee\\Bundle\\DocumentationBundle\\Controller\\SecondController\n    ...\n\n\n\n\nAnd to finish we need to define the entry point of your admin interface.\n\n\nbundle:\n  ...\n  admin_entry_point: doc.index\n\n\n\n\n\n\nThe entry point it's compose by controller name that refer the name you declare in \nadmin_controller\n section, dot separator and action name without the Action key word index refer to \nindexAction\n.\n\n\n\n\nController and Actions\n\n\nYour admin controller class have to extend \nAbstractAdminBundleController\n to work correctly in automated mode.\n\n\n?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Controller;\nuse BackBee\\Bundle\\AbstractAdminBundleController;\n\nclass DocController extends AbstractAdminBundleController\n{\n}\n\n\n\n\n\n\nThis represent the minimum necessary to implement your admin controller.\n\n\n\n\nBy extending \nAbstractAdminBundleController\n your controller can access to lot of methods:\n\n\n\n\ngetApplication()\n Returns current application\n\n\ngetContainer()\nReturns the dependency injection container\n\n\ngetRequest()\n Returns current request\n\n\ngetEntityManager()\n Returns doctrine entity manager\n\n\ngetRepository($entity)\n Returns the repository corresponding of the entity name passed in paramater\n\n\nisGranted($permission, $object)\n Returns true if the current user have the permission to do the action on the object\n\n\ngetTranslator()\n Returns translator object\n\n\nrender($template, $parameters)\n Returns template parsed and rendered first argument is the template file starting from your rendering folder and $parameters are the variables necessary to render the template.\n\n\ncreateResponse($content, $statusCode, $contentType)\n Generate your own response, $content parameter is the body of the response, $statusCode correspond to the\n\n\nredirect($url, $statusCode)\n Create a redirection response\n\n\nnotifyUser($type, $message)\n Generate an notification on the backoffice to the user there is 3 types availble \nself::NOTIFY_SUCCESS\n (green), \nself::NOTIFY_WARNING\n (orange) and \nself::NOTIFY_ERROR\n (red).\n\n\n\n\nNow you have to implement some actions in your controller by default an action have to return an \nString\n, before we have defined that the entry point of the bundle administration it was do in the \nindexAction\n.\nThe index action return an array of values and need no parameters to work, \nindexAction\n it's compose of an \nfindAll\n and one \nrender\n\n\npublic function indexAction()\n{\n    $docs = $this-\ngetRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')-\nfindAll();\n\n    return $this-\nrender('Doc/Index.twig', ['docs' =\n $docs]);\n}\n\n\n\n\nTo consult one object doc in particular we need an showAction. This action need an identifier to retrieve the good object and render it.\n\n\npublic function showAction($id)\n{\n    $doc = $this-\ngetRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')-\nfind($id);\n\n    return $this-\nrender('Doc/Doc.twig', ['doc' =\n $doc]);\n}\n\n\n\n\nRouting\n\n\nBy default on all application, you to expose some route and do the matching with an controller and an action. In the bundle administration the routing is dynamic and automatic. To generate the URL you have 3 helpers to render the URL into your template.\nImplicit route are defined like this: \nRoute is composed by the bundle name, controller name and action name separated by a dot\n.\n\n\n\n\nIn the case of the method \nshowAction\n from \nDocController\n into \nDocumentationBundle\n the route is equal to \ndocumentation.doc.show\n. \ndocumentation\n matches to the name declared into \nbundle.yml\n file in your global configuration and \ndoc\n is the name you gave to your controller into admin_controller section of your \nconfig.yml\n into your bundle configuration file.\n\n\n\n\n\n\nbundleAdminUrl($route, $parameters)\n this helper generate your URL it need a \"route\" and optionally parameters.\n\n\nbundleAdminLink($route, $parameters, $httpMethod)\n this helper generate all value necessary to an automated system, it work like the previous helper, but accept an third parameter to specify the HTTP method you want use when the link was cliqued. By default the HTTP method is GET.\n\n\nbundleAdminForm($route, $parameters, $httpMethod)\n work like \nbundleAdminLink\n but by default the HTTP method is POST.\n\n\n\n\n\n\nbundleAdminLink\n  \nbundleAdminForm\n generate more than just an URL and it need to be goodly used.\n\n\nbundleAdminUrl\n is required only if you want create an custom system and bypass the automated system.\n\n\n\n\nUsage of the \nbundleAdminLink\n into an template to reach the \nshowAction\n\n\na {{ this.bundleAdminLink(\ndocumentation.doc.show\n, {'id': 1})|raw }}\n\n    Show the first document\n\n/a\n\n\n\n\n\nAnd the result before rendering is:\n\n\na data-bundle=\nlink\n href=\n/bundle/documentation/doc/show/1\n data-http-method=\nread\n\n   Show the first document\n\n/a\n\n\n\n\n\n\n\nAs you can see the id 1 do part of the URL and is not present as query. This is because your \nshowAction\n method require an $id to work and the helper do automatically the matching behind the action and your parameters.\n\n\nIn the case of \nbundleAdminForm\n, this helper work correctly only in \nform\n HTML tag.", 
            "title": "Create bundle administration"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_bundle_administration/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developper-documentation/cookbooks/create_bundle_administration/#create-bundle-administration", 
            "text": "Configuration :  To create an bundle administration we need to declare some parameters into the bundle configuration. Then open your config file into  Config/config.yml  Define your controller  bundle:\n  ...\n  admin_controller:\n    doc: BackBee\\Bundle\\DocumentationBundle\\Controller\\DocController   You can declare controller as much as you want.   bundle:\n  ...\n  admin_controller:\n    first: BackBee\\Bundle\\DocumentationBundle\\Controller\\FirstController\n    second: BackBee\\Bundle\\DocumentationBundle\\Controller\\SecondController\n    ...  And to finish we need to define the entry point of your admin interface.  bundle:\n  ...\n  admin_entry_point: doc.index   The entry point it's compose by controller name that refer the name you declare in  admin_controller  section, dot separator and action name without the Action key word index refer to  indexAction .   Controller and Actions  Your admin controller class have to extend  AbstractAdminBundleController  to work correctly in automated mode.  ?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Controller;\nuse BackBee\\Bundle\\AbstractAdminBundleController;\n\nclass DocController extends AbstractAdminBundleController\n{\n}   This represent the minimum necessary to implement your admin controller.   By extending  AbstractAdminBundleController  your controller can access to lot of methods:   getApplication()  Returns current application  getContainer() Returns the dependency injection container  getRequest()  Returns current request  getEntityManager()  Returns doctrine entity manager  getRepository($entity)  Returns the repository corresponding of the entity name passed in paramater  isGranted($permission, $object)  Returns true if the current user have the permission to do the action on the object  getTranslator()  Returns translator object  render($template, $parameters)  Returns template parsed and rendered first argument is the template file starting from your rendering folder and $parameters are the variables necessary to render the template.  createResponse($content, $statusCode, $contentType)  Generate your own response, $content parameter is the body of the response, $statusCode correspond to the  redirect($url, $statusCode)  Create a redirection response  notifyUser($type, $message)  Generate an notification on the backoffice to the user there is 3 types availble  self::NOTIFY_SUCCESS  (green),  self::NOTIFY_WARNING  (orange) and  self::NOTIFY_ERROR  (red).   Now you have to implement some actions in your controller by default an action have to return an  String , before we have defined that the entry point of the bundle administration it was do in the  indexAction .\nThe index action return an array of values and need no parameters to work,  indexAction  it's compose of an  findAll  and one  render  public function indexAction()\n{\n    $docs = $this- getRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')- findAll();\n\n    return $this- render('Doc/Index.twig', ['docs' =  $docs]);\n}  To consult one object doc in particular we need an showAction. This action need an identifier to retrieve the good object and render it.  public function showAction($id)\n{\n    $doc = $this- getRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')- find($id);\n\n    return $this- render('Doc/Doc.twig', ['doc' =  $doc]);\n}  Routing  By default on all application, you to expose some route and do the matching with an controller and an action. In the bundle administration the routing is dynamic and automatic. To generate the URL you have 3 helpers to render the URL into your template.\nImplicit route are defined like this:  Route is composed by the bundle name, controller name and action name separated by a dot .   In the case of the method  showAction  from  DocController  into  DocumentationBundle  the route is equal to  documentation.doc.show .  documentation  matches to the name declared into  bundle.yml  file in your global configuration and  doc  is the name you gave to your controller into admin_controller section of your  config.yml  into your bundle configuration file.    bundleAdminUrl($route, $parameters)  this helper generate your URL it need a \"route\" and optionally parameters.  bundleAdminLink($route, $parameters, $httpMethod)  this helper generate all value necessary to an automated system, it work like the previous helper, but accept an third parameter to specify the HTTP method you want use when the link was cliqued. By default the HTTP method is GET.  bundleAdminForm($route, $parameters, $httpMethod)  work like  bundleAdminLink  but by default the HTTP method is POST.    bundleAdminLink    bundleAdminForm  generate more than just an URL and it need to be goodly used.  bundleAdminUrl  is required only if you want create an custom system and bypass the automated system.   Usage of the  bundleAdminLink  into an template to reach the  showAction  a {{ this.bundleAdminLink( documentation.doc.show , {'id': 1})|raw }} \n    Show the first document /a   And the result before rendering is:  a data-bundle= link  href= /bundle/documentation/doc/show/1  data-http-method= read \n   Show the first document /a    As you can see the id 1 do part of the URL and is not present as query. This is because your  showAction  method require an $id to work and the helper do automatically the matching behind the action and your parameters.  In the case of  bundleAdminForm , this helper work correctly only in  form  HTML tag.", 
            "title": "Create bundle administration"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/", 
            "text": "Components\n\n\nThe ClassContent component\n\n\nClassContent Parameters\n\n\nParameters allow to configure contents. ClassContent parameters is used usually in the listener but can be used everywhere. ClassContent parameters are contributed in back office by the user with the gearing button of Block.\n\n\nParameters is builded from the block's YAML like\n\n\nBlockDemo:\n    properties:\n        name: Block demo\n        description: \nBlock for demonstration purposes\n\n        category: [Demo]\n    elements:\n        text:\n            type: BackBee\\ClassContent\\Element\\Text\n    parameters:\n        mytext:\n            label: 'My text'\n            type: 'text'\n            value: ''\n        myselect:\n            label: 'My select'\n            type: 'select'\n            options:\n                'foo': 'Foo'\n                'bar': 'Bar'\n            value: ['foo']\n\n\n\n\n\nUse parameters\n\n\nIf ClassContent Parameters are not validated by user the content parameters are overriden by revision parameters.\n\nOnly value of the parameter is saved.\n\n\nTo get default parameters:\n\n\n?php\n$params = $content-\ngetDefaultParams();\n\n/** That returns all parameters with definitions and default values:\n *  array (size=2)\n *    'mytext' =\n\n *      array (size=3)\n *        'label' =\n string 'My text' (length=7)\n *        'type' =\n string 'text' (length=4)\n *        'value' =\n string '' (length=0)\n *    'myselect' =\n\n *      array (size=4)\n *        'label' =\n string 'My select' (length=9)\n *        'type' =\n string 'select' (length=6)\n *        'options' =\n\n *          array (size=2)\n *            'foo' =\n string 'Foo' (length=3)\n *            'bar' =\n string 'Bar' (length=3)string 'yolo' (length=4)\n *        'value' =\n\n *          array (size=1)\n *            0 =\n string 'foo' (length=3)\n */\n\n\n\n\nTo get all parameters :\n\n\n?php\n\n$params = $content-\ngetAllParams();\n\n/** That returns all parameters with definitions and new values\n *  array (size=2)\n *    'mytext' =\n\n *      array (size=3)\n *        'label' =\n string 'My text' (length=7)\n *        'type' =\n string 'text' (length=4)\n *        'value' =\n string '' (length=0)\n *    'myselect' =\n\n *      array (size=4)\n *        'label' =\n string 'My select' (length=9)\n *        'type' =\n string 'select' (length=6)\n *        'options' =\n\n *          array (size=2)\n *            'foo' =\n string 'Foo' (length=3)\n *            'bar' =\n string 'Bar' (length=3)\n *        'value' =\n\n *          array (size=1)\n *            0 =\n string 'foo' (length=3)\n */\n\n\n\n\nTo get one param:\n\n\n?php\n$param = $content-\ngetParam('mytext');\n\n/** That returns the definition and new value\n *  array (size=3)\n *    'label' =\n string 'My text' (length=7)\n *    'type' =\n string 'text' (length=4)\n *    'value' =\n string '' (length=0)\n */\n\n\n\n\nTo get the value of the param:\n\n\n?php\n$paramValue = $content-\ngetParamValue('mytext');\n\n// That returns the new value string '' (length=0)\n\n\n\n\nTo set a value, you need to set up the same type you declare in the YAML file as value:\n\n\n?php\n$content-\nsetParam('mytext', 'foo');\n$param = $content-\ngetParamValue('mytext')\n\n// That returns a new value set  string 'foo' (length=3)\n\n\n\n\nParameters reference\n\n\n\n\ncheckbox\n\n\ndatetimepicker\n\n\nhidden\n\n\nlinkSelector\n\n\nmediaSelector\n\n\nnodeSelector\n\n\npassword\n\n\nradio\n\n\nselect\n\n\ntext\n\n\ntextarea\n\n\n\n\nAll parameters has default options:\n\n\nDefault options\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nlabel\n\n\nString\n\n\nLabel is displayed above the field\n\n\nEmpty\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nMixed\n\n\nThis field must be set and allows to describe the  parameter's type\n\n\nNone\n\n\nYes\n\n\n\n\n\n\ntype\n\n\nString\n\n\nKey of one of available parameters\n\n\nNone\n\n\nYes\n\n\n\n\n\n\n\n\n\n\nCheckbox\n\n\nLike HTML checkbox attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\ninline\n\n\nBoolean\n\n\nDisplay checkbox inline\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected checkboxes\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mycheckbox:\n        type: 'checkbox'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mycheckbox'); // sarray('foo')\n\n\n\n\n\n\nDatetime picker\n\n\nText element with a datetimepicker\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nNumber\n\n\nIt is an timestamp value\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mydatetimepicker:\n        type: 'datetimepicker'\n        value: 1435573740\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mydatetimepicker'); // 1435573740\n\n\n\n\n\n\nHidden\n\n\nLike HTML hidden attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    myhidden:\n        type: 'hidden'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myhidden'); // foo\n\n\n\n\n\n\nLink selector\n\n\nLink selector allows to choose a link from one of your website pages or an external link.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains url / title / pageUid / target\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mylinkselector:\n        type: 'linkSelector'\n        value: []\n\n\n\n\n?php\n# Example with select one link\n$param = $content-\ngetParamValue('mylinkselector');\n// array('url' =\n '/foo', 'title' =\n 'Foo', 'pageUid' =\n 'anPageUid', 'target' =\n '_self')\n\n\n\n\n Page tree \n:\nWe recommend to retrieve the url from the page entity instead of the url attribute because the url can change.\n\n\n External link \n :\nIn this case, note the pageUid attribute is (obviously) null.\n\n\n\n\nMedia selector\n\n\nMedia selector allow to choose a list of media in the media library.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains folder_uid / image / media_id / title /type / uid\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mymediaselector:\n        type: 'mediaSelector'\n        value: []\n\n\n\n\n?php\n# Example with select one media\n$param = $content-\ngetParamValue('mymediaselector');\n// array(array('folder_uid' =\n 'anFolderUid', 'image' =\n 'imageUrl', 'media_id' =\n '1', 'title' =\n '_Foo', 'type' =\n 'Media/Image', 'uid' =\n 'anUid'))\n\n\n\n\n\n\nNode selector\n\n\nNode selector allows to choose a page from tree\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains url  pageUid / title\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mynodeselector:\n        type: 'nodeSelector'\n        value: []\n\n\n\n\n# Example of node selection\n$param = $content-\ngetParamValue('mynodeselector');\n# array('pageUid' =\n 'anPageUid', 'title' =\n 'Foo')\n\n\n\n\nWe recommend to retrieve the title from the page entity instead of the title attribute because the title can change.\n\n\n\n\nPassword\n\n\nLike HTML password attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mypassword:\n        type: 'password'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mypassword'); // foo\n\n\n\n\n\n\nRadio\n\n\nLike HTML radio attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\ninline\n\n\nBoolean\n\n\nDisplay radio inline\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected radio\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    myradio:\n        type: 'radio'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myradio'); // array('foo')\n\n\n\n\n\n\nSelect\n\n\nLike HTML select attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected radio\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nmultiple\n\n\nBoolean\n\n\nAllows multiple selection\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mypassword:\n        type: 'select'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        multiple: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myradio'); //array('foo')\n\n\n\n\n\n\nText\n\n\nLike HTML text attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mytext:\n        type: 'text'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mypassword'); // foo\n\n\n\n\n\n\nTextarea\n\n\nLike HTML textearea attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\nrows\n\n\nString\n\n\nthe rows html attribute\n\n\n5\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mytextearea:\n        type: 'textarea'\n        value: 'BackBee'\n        rows: 10\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mytextearea'); // BackBee\n\n\n\n\n\n\nSpecial parameters\n\n\nRendermode\n\n\nRendermode parameters allow to list automatically rendermodes of the content and use them directly.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nSelected rendermode\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nparameters:\n    rendermode:\n        type: 'select'\n        value: []\n\n\n\n\nThe key must be 'rendermode'", 
            "title": "ClassContent"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/#the-classcontent-component", 
            "text": "", 
            "title": "The ClassContent component"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/#classcontent-parameters", 
            "text": "Parameters allow to configure contents. ClassContent parameters is used usually in the listener but can be used everywhere. ClassContent parameters are contributed in back office by the user with the gearing button of Block.  Parameters is builded from the block's YAML like  BlockDemo:\n    properties:\n        name: Block demo\n        description:  Block for demonstration purposes \n        category: [Demo]\n    elements:\n        text:\n            type: BackBee\\ClassContent\\Element\\Text\n    parameters:\n        mytext:\n            label: 'My text'\n            type: 'text'\n            value: ''\n        myselect:\n            label: 'My select'\n            type: 'select'\n            options:\n                'foo': 'Foo'\n                'bar': 'Bar'\n            value: ['foo']  Use parameters  If ClassContent Parameters are not validated by user the content parameters are overriden by revision parameters. Only value of the parameter is saved.  To get default parameters:  ?php\n$params = $content- getDefaultParams();\n\n/** That returns all parameters with definitions and default values:\n *  array (size=2)\n *    'mytext' = \n *      array (size=3)\n *        'label' =  string 'My text' (length=7)\n *        'type' =  string 'text' (length=4)\n *        'value' =  string '' (length=0)\n *    'myselect' = \n *      array (size=4)\n *        'label' =  string 'My select' (length=9)\n *        'type' =  string 'select' (length=6)\n *        'options' = \n *          array (size=2)\n *            'foo' =  string 'Foo' (length=3)\n *            'bar' =  string 'Bar' (length=3)string 'yolo' (length=4)\n *        'value' = \n *          array (size=1)\n *            0 =  string 'foo' (length=3)\n */  To get all parameters :  ?php\n\n$params = $content- getAllParams();\n\n/** That returns all parameters with definitions and new values\n *  array (size=2)\n *    'mytext' = \n *      array (size=3)\n *        'label' =  string 'My text' (length=7)\n *        'type' =  string 'text' (length=4)\n *        'value' =  string '' (length=0)\n *    'myselect' = \n *      array (size=4)\n *        'label' =  string 'My select' (length=9)\n *        'type' =  string 'select' (length=6)\n *        'options' = \n *          array (size=2)\n *            'foo' =  string 'Foo' (length=3)\n *            'bar' =  string 'Bar' (length=3)\n *        'value' = \n *          array (size=1)\n *            0 =  string 'foo' (length=3)\n */  To get one param:  ?php\n$param = $content- getParam('mytext');\n\n/** That returns the definition and new value\n *  array (size=3)\n *    'label' =  string 'My text' (length=7)\n *    'type' =  string 'text' (length=4)\n *    'value' =  string '' (length=0)\n */  To get the value of the param:  ?php\n$paramValue = $content- getParamValue('mytext');\n\n// That returns the new value string '' (length=0)  To set a value, you need to set up the same type you declare in the YAML file as value:  ?php\n$content- setParam('mytext', 'foo');\n$param = $content- getParamValue('mytext')\n\n// That returns a new value set  string 'foo' (length=3)", 
            "title": "ClassContent Parameters"
        }, 
        {
            "location": "/developper-documentation/components/classcontent/#parameters-reference", 
            "text": "checkbox  datetimepicker  hidden  linkSelector  mediaSelector  nodeSelector  password  radio  select  text  textarea   All parameters has default options:  Default options      Type  Description  Default  Mandatory      label  String  Label is displayed above the field  Empty  No    value  Mixed  This field must be set and allows to describe the  parameter's type  None  Yes    type  String  Key of one of available parameters  None  Yes      Checkbox  Like HTML checkbox attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    inline  Boolean  Display checkbox inline  false  No    value  Array  List of selected checkboxes  Empty array  Yes     Example :  parameters:\n    mycheckbox:\n        type: 'checkbox'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true  ?php\n$param = $content- getParamValue('mycheckbox'); // sarray('foo')   Datetime picker  Text element with a datetimepicker      Type  Description  Default  Mandatory      value  Number  It is an timestamp value  Empty  Yes     Example :  parameters:\n    mydatetimepicker:\n        type: 'datetimepicker'\n        value: 1435573740  ?php\n$param = $content- getParamValue('mydatetimepicker'); // 1435573740   Hidden  Like HTML hidden attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    myhidden:\n        type: 'hidden'\n        value: 'foo'  ?php\n$param = $content- getParamValue('myhidden'); // foo   Link selector  Link selector allows to choose a link from one of your website pages or an external link.      Type  Description  Default  Mandatory      value  Json  Object which contains url / title / pageUid / target  Empty array  Yes     Example :  parameters:\n    mylinkselector:\n        type: 'linkSelector'\n        value: []  ?php\n# Example with select one link\n$param = $content- getParamValue('mylinkselector');\n// array('url' =  '/foo', 'title' =  'Foo', 'pageUid' =  'anPageUid', 'target' =  '_self')   Page tree  :\nWe recommend to retrieve the url from the page entity instead of the url attribute because the url can change.   External link   :\nIn this case, note the pageUid attribute is (obviously) null.   Media selector  Media selector allow to choose a list of media in the media library.      Type  Description  Default  Mandatory      value  Json  Object which contains folder_uid / image / media_id / title /type / uid  Empty array  Yes     Example :  parameters:\n    mymediaselector:\n        type: 'mediaSelector'\n        value: []  ?php\n# Example with select one media\n$param = $content- getParamValue('mymediaselector');\n// array(array('folder_uid' =  'anFolderUid', 'image' =  'imageUrl', 'media_id' =  '1', 'title' =  '_Foo', 'type' =  'Media/Image', 'uid' =  'anUid'))   Node selector  Node selector allows to choose a page from tree      Type  Description  Default  Mandatory      value  Json  Object which contains url  pageUid / title  Empty array  Yes     Example :  parameters:\n    mynodeselector:\n        type: 'nodeSelector'\n        value: []  # Example of node selection\n$param = $content- getParamValue('mynodeselector');\n# array('pageUid' =  'anPageUid', 'title' =  'Foo')  We recommend to retrieve the title from the page entity instead of the title attribute because the title can change.   Password  Like HTML password attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    mypassword:\n        type: 'password'\n        value: 'foo'  ?php\n$param = $content- getParamValue('mypassword'); // foo   Radio  Like HTML radio attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    inline  Boolean  Display radio inline  false  No    value  Array  List of selected radio  Empty array  Yes     Example :  parameters:\n    myradio:\n        type: 'radio'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true  ?php\n$param = $content- getParamValue('myradio'); // array('foo')   Select  Like HTML select attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    value  Array  List of selected radio  Empty array  Yes    multiple  Boolean  Allows multiple selection  false  No     Example :  parameters:\n    mypassword:\n        type: 'select'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        multiple: true  ?php\n$param = $content- getParamValue('myradio'); //array('foo')   Text  Like HTML text attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    mytext:\n        type: 'text'\n        value: 'foo'  ?php\n$param = $content- getParamValue('mypassword'); // foo   Textarea  Like HTML textearea attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes    rows  String  the rows html attribute  5  No     Example :  parameters:\n    mytextearea:\n        type: 'textarea'\n        value: 'BackBee'\n        rows: 10  ?php\n$param = $content- getParamValue('mytextearea'); // BackBee   Special parameters  Rendermode  Rendermode parameters allow to list automatically rendermodes of the content and use them directly.      Type  Description  Default  Mandatory      value  Array  Selected rendermode  Empty  Yes     parameters:\n    rendermode:\n        type: 'select'\n        value: []  The key must be 'rendermode'", 
            "title": "Parameters reference"
        }, 
        {
            "location": "/developper-documentation/components/config/", 
            "text": "Components\n\n\nThe Config component\n\n\nThis component is used in BackBee to set parameters from YAML files into the Container.\n\n\nHow the Config component work ?\n\n\nThe BackBee Config Component provides a \nConfig\n object able to:\n\n\n\n\nParse YAML files from a directory;\n\n\nPersist this configuration in file or in database;\n\n\nSet this configuration in \nBackBee Container\n;\n\n\nSave and load configuration from \nBackBee Cache\n;\n\n\n\n\n?php\n\nuse BackBee\\Cache\\AbstractCache;\nuse BackBee\\Config\\Config;\nuse BackBee\\DependencyInjection\\Container;\nuse BackBee\\DependencyInjection\\DispatchTagEventInterface;\nuse BackBee\\DependencyInjection\\Dumper\\DumpableServiceInterface;\n\nclass Config implements DispatchTagEventInterface, DumpableServiceInterface\n{\n    public function __construct(\n        $basedir,\n        AbstractCache $cache = null,\n        Container $container = null,\n        $debug = false,\n        array $yml_to_ignore = []\n    ){/*..*/}\n}\n\n?\n\n\n\n\n\nThis component is not related and not compatible with Symfony Config component.\n\n\nYAML parsing, filtering and extending\n\n\nThe BackBee Config Component can take a valid directory as argument, and merge the configuration according to the data set\nin this YAML files. If you don't know YAML, you can take a look to the \nSymfony YAML format documentation\n.\n\n\nMoreover, BackBee Config component allows you to ignore some files.\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function returnConfiguration(array $filesToIgnore)\n    {\n        return new Config(self::DIRECTORY, null, null, false, $filesToIgnore);\n    }\n}\n\n?\n\n\n\n\n\nThis way, the ignored files won't be parsed.\n\n\nThanks to the \nBackBee environments\n, you can also extend and improve your default configuration.\nFor instance, let's say you want to add a specific configuration when your are in a \"testing\" environment.\n\n\nYou can set the environment this way:\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function TestingConfiguration()\n    {\n        $config = new Config('/repository/Config', null, null, false, []);\n\n        return $config-\nsetEnvironment('testing');\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config\n         * /repository/Config/testing\n         * and we are also able to parse specific \nenvironment files\n:\n         * /repository/Config/foo.testing.yml\n         */\n    }\n}\n\n?\n\n\n\n\n\nThis is simple and powerful, you can be very specific on the configuration you want to use.\nConfigurations keys and parameters are merged recursively, starting from base directory to the environnement directory.\nThank to the \"On cascade system\", you can also add a new directory to allow an override of the current configuration.\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function overrideTestingConfiguration(Config $config, $directory)\n    {\n        return $config-\nextend($directory);\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config/\n$directory\n\n         * If a key is declared in \n$directory\n configuration files, the configuration is overriden\n         */\n    }\n}\n\n?\n\n\n\n\n\nConfiguration persisting\n\n\nThe BackBee Config Component can persist configurations in file or in database, you can also create your own \"persistors\"\nthanks to the \nBackBee\\Config\\PersistorInterface\n.\n\n\nFor now, two persistors are provided in BackBee CMS:\n\n\n\n\nthe \nFile\n Persistor allows you to write and override the main configuration file (config.yml)\n\n\nthe \nRegistry\n Persistor is a simple database Key/Value system\n\n\n\n\nIf we take a look at the BackBee CMS configuration:\n\n\nconfig:\n    save_in_registry: true # default value: true\n    persistor: [BackBee\\Config\\Persistor\\File, BackBee\\Config\\Persistor\\Registry]\n\n\n\n\n\n\nsave_in_registry\n is a particular option: if true, this means BackBee will try to look for an overidden configuration\n  stored in Registry.\n\n\npersistor\n is the list of activated persistors. BackBee will loop on each and try to find configuration. If no one\n  provides the requested configuration, an exception will be thrown.\n\n\n\n\nConfiguration caching\n\n\nThe BackBee Config Component is fully compatible with BackBee Cache component.\n\n\nWhen you create your Config object, you can pass an instance of \nBackBee\\Cache\\AbstractCache\n as a second argument.\nThis way, in non-debug mode (fourth argument, \nfalse\n by default), the second time you get the information, the configuration\nwill be constructed from cache instead of built again from files or database registry.", 
            "title": "Config"
        }, 
        {
            "location": "/developper-documentation/components/config/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/config/#the-config-component", 
            "text": "This component is used in BackBee to set parameters from YAML files into the Container.", 
            "title": "The Config component"
        }, 
        {
            "location": "/developper-documentation/components/config/#how-the-config-component-work", 
            "text": "The BackBee Config Component provides a  Config  object able to:   Parse YAML files from a directory;  Persist this configuration in file or in database;  Set this configuration in  BackBee Container ;  Save and load configuration from  BackBee Cache ;   ?php\n\nuse BackBee\\Cache\\AbstractCache;\nuse BackBee\\Config\\Config;\nuse BackBee\\DependencyInjection\\Container;\nuse BackBee\\DependencyInjection\\DispatchTagEventInterface;\nuse BackBee\\DependencyInjection\\Dumper\\DumpableServiceInterface;\n\nclass Config implements DispatchTagEventInterface, DumpableServiceInterface\n{\n    public function __construct(\n        $basedir,\n        AbstractCache $cache = null,\n        Container $container = null,\n        $debug = false,\n        array $yml_to_ignore = []\n    ){/*..*/}\n}\n\n?   This component is not related and not compatible with Symfony Config component.", 
            "title": "How the Config component work ?"
        }, 
        {
            "location": "/developper-documentation/components/config/#yaml-parsing-filtering-and-extending", 
            "text": "The BackBee Config Component can take a valid directory as argument, and merge the configuration according to the data set\nin this YAML files. If you don't know YAML, you can take a look to the  Symfony YAML format documentation .  Moreover, BackBee Config component allows you to ignore some files.  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function returnConfiguration(array $filesToIgnore)\n    {\n        return new Config(self::DIRECTORY, null, null, false, $filesToIgnore);\n    }\n}\n\n?   This way, the ignored files won't be parsed.  Thanks to the  BackBee environments , you can also extend and improve your default configuration.\nFor instance, let's say you want to add a specific configuration when your are in a \"testing\" environment.  You can set the environment this way:  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function TestingConfiguration()\n    {\n        $config = new Config('/repository/Config', null, null, false, []);\n\n        return $config- setEnvironment('testing');\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config\n         * /repository/Config/testing\n         * and we are also able to parse specific  environment files :\n         * /repository/Config/foo.testing.yml\n         */\n    }\n}\n\n?   This is simple and powerful, you can be very specific on the configuration you want to use.\nConfigurations keys and parameters are merged recursively, starting from base directory to the environnement directory.\nThank to the \"On cascade system\", you can also add a new directory to allow an override of the current configuration.  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function overrideTestingConfiguration(Config $config, $directory)\n    {\n        return $config- extend($directory);\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config/ $directory \n         * If a key is declared in  $directory  configuration files, the configuration is overriden\n         */\n    }\n}\n\n?", 
            "title": "YAML parsing, filtering and extending"
        }, 
        {
            "location": "/developper-documentation/components/config/#configuration-persisting", 
            "text": "The BackBee Config Component can persist configurations in file or in database, you can also create your own \"persistors\"\nthanks to the  BackBee\\Config\\PersistorInterface .  For now, two persistors are provided in BackBee CMS:   the  File  Persistor allows you to write and override the main configuration file (config.yml)  the  Registry  Persistor is a simple database Key/Value system   If we take a look at the BackBee CMS configuration:  config:\n    save_in_registry: true # default value: true\n    persistor: [BackBee\\Config\\Persistor\\File, BackBee\\Config\\Persistor\\Registry]   save_in_registry  is a particular option: if true, this means BackBee will try to look for an overidden configuration\n  stored in Registry.  persistor  is the list of activated persistors. BackBee will loop on each and try to find configuration. If no one\n  provides the requested configuration, an exception will be thrown.", 
            "title": "Configuration persisting"
        }, 
        {
            "location": "/developper-documentation/components/config/#configuration-caching", 
            "text": "The BackBee Config Component is fully compatible with BackBee Cache component.  When you create your Config object, you can pass an instance of  BackBee\\Cache\\AbstractCache  as a second argument.\nThis way, in non-debug mode (fourth argument,  false  by default), the second time you get the information, the configuration\nwill be constructed from cache instead of built again from files or database registry.", 
            "title": "Configuration caching"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/", 
            "text": "Components\n\n\nThe Event Listener component\n\n\nEvents\n are a common and effective way to tie together loosely coupled components in an application.\nAn event is generally used to broadcast a change that has occured during a process. If a \ncomponent\n is\ninterested in a particular event, it can \nlisten\n to it. When this particular event is triggered, a \nmethod\n,\noften called \ncallback\n or \nhandler\n is executed. Events are convenient ways to share\ndata between components.\nIn \nBackBee\n, events are triggered by an \nEventDispatcher\n and an \nEventListener\n is used to listen to them.\n\n\nEvent\n\n\nNamespace: BackBee\\Event\\Event\n\n\nThe Backbee event class extend \nsfEvent\n and allows us to create a generic \nEvent\n object.\nA generic event object has two properties: \ntarget\n and \nargs\n;\nThe target property represents the target of the event. The \nargs\n is an optional associated map.\nWhen the \nargs\n property is provided, it's sent to the listeners.\nCustom Event can be created by extending the class \nBackBee\\Event\\Event\n.\n\n\n?php\n$myHelloEvent = new Event($target, array(\nmessage\n=\nHello BackBee\n);\n\n\n\n\n\nEvent Listener\n\n\nNamespace: BackBee\\Event\\EventListener\n\n\nTo listen to an event you must use the \naddListener\n method of the \nEventDispatcher\n.\n\naddListener\n takes three parameters. The first one is the name of the event that will be triggered, the second is an array whose first element\nis a class path and the second is a method. The last parameter is the priority of the event. Listener with higher priority will be triggered first.\n\n\n$this-\napplication-\ngetEventDispatcher()-\naddListener(\"loading.event\", array(\"BackBee/Event/Listener/HelloListener\", \"sayHello\"));\n\n\n\nHere, we register the listener \nHelloListener\n to be executed when the event \nloading.event\n is occured.\n\n\n    \n?php\n\n        namespace BackBee\\Event\\Listener;\n        use BackBee\\Event\\Event;\n\n        class HelloListener {\n\n            public static sayHello (Event $event) {\n\n                $dispatcher = $event-\ngetDispatcher();\n\n                if ($event-\nhasArguments(\nmessage\n)) {\n                    $message = $event-\nget(\nmessage\n);\n                    if ( null !== $dispatcher-\ngetApplication()) {\n                        $dispatcher-\ngetApplication()-\ngetLogging()-\nnotice($message);\n                    }\n                }\n            }\n        }\n\n    ?\n\n\n\n\n\nNotice that the event object has access to the \napplication\n \nvia\n the \nEventDispacher\n and that the \nsayHello\n is a \nstatic\n method.\n\n\nEvent Dispatcher\n\n\nNamespace: BackBee\\Event\\EventListener\n\n\nEvents are \ndispatched\n or \ntriggered\n by the \nEventDispatcher\n by using the method \ntriggerEvent\n\nThe sample bellow shows how to listen to an event.\n\n\nTo trigger an event, we must use the \nEventDispatcher\n. It provides, among others, a \ndispatch\n method that takes two arguments. A name and an event object.\n\n\n?php\n    $this-\napplication-\ngetEventDispatcher()-\ndispatch(\nloading.event\n, $myHelloEvent);\n\n\n\n\nWhen the \nloading.event\n is dispatched by the \nEventDispatcher\n, all the registered listeners will be executed. In our example,\nthe static \nsayHello\n method of the \nBackbee/Event/Listener/HelloListener\n will be called.\n\n\nEvents from Class Content Component\n\n\nOne of the main purpose of \nBackbee\n is to render contents. As we have seen, a\ncontent is defined in a \n.yml\n file. Content creation and content rendering go\nthrough many phases that \nBackbee\n exposes with events. By instance, an event is triggered\nwhen a content is created, before and after a content has been saved, when the rendering process\nis started, while the content is been rendered, after the renderer process and so on. These events\nallow us the act in different ways on the contents lifecycle and rendering process itself.\n\n\nClassContent events are similar to custom events. But, as they take place when the main application\nis dealing with a request, a common way to listen to them is to use an \nevent.yml\n config file.\nWill try to local event file in the \nrepository/Config\n folder. Bellow is an example of how to\nuse the file.\n\n\n    article.article.render:\n        listeners:\n            - [BackBee\\Event\\Listener\\ArticleListener, onRender]\n\n    social.facebook.prerender:\n        listeners:\n            - [BackBee\\Event\\Listener\\Socialistener, PrerenderFacebook]\n\n\n\n\nevents.yml\n is a declarative way to add listeners to \nClassContentEvents\n event. Under the hook,\nthis yaml file is parsed and the \nEventDispatcher\n is used to register the listeners.\nIn our example,  \narticle.article.render\n and \nsocial.facebook.prerender\n are events names.\nBy convention \nBackBee\n transforms ClassContent class path to event name. Let's take a look at our events files.\n\n\nAccording to our \nevent.yml\n, the \narticle.article.render\n event will be triggered when\nthe content \nClassContent/Article/Article.yml\n is about the be rendered whereas\nthe 'social.facebook.prerender' will be triggered \nbefore\n the content \nClassContent/Social/Facebook.yml\n\nwas rendered.\n\n*.render\n  and \n*.prerender\n are events triggered by the \nRenderer\n object. Bellow is the list of\nall the Renderer events.\n\n\n\n\n*.prerender\n : is triggered \nbefore\n the content is being rendered;\n\n\n*.render\n : when the content is about to be rendered;\n\n\n*.postrender\n : after the render process.\n\n\n\n\nHowever there is no strong difference between \nrender\n and \npostrender\n.\n\n\nIn BackBee all the contents are \nDoctrine\n entities. These doctrine events are also available for all the contents.\n\n\n\n\npreremove\n\n\npostremove\n\n\npostupdate\n\n\npreupdate\n\n\nupdate\n\n\nprepersist\n\n\npostpersist\n\n\npostload\n\n\nonflush\n\n\n\n\nClassContent Listener\n\n\nTo listen to a ClassContentEvent we have to create a \nListener\n class. By default BackBee\nwill look for Listener in the repository/Config/Listener folder.\n\n\n    \n?php\n        namespace BackBee\\Event\\Listener,\n        use BackBee\\Event\\Event;\n\n        class ArticleListener extends Event {\n\n            public static function onRender(Event $event){\n                /* The renderer object */\n                $renderer = $event-\ngetEventArgs();\n\n                /* The eventDispatcher */\n                $eventDistacher = $event-\ngetDispatcher();\n\n                /* the BackBee application */\n                $application = $eventDistacher-\ngetApplication();\n\n                /* The article classcontent */\n                $content = $renderer-\ngetObject();\n\n                /* Add a new parameter that will be available in the content template */\n                $renderer-\nassign('myParams', \nmy Param value\n);\n            }\n        }\n    ?\n\n\n\n\n\nEvent inheritance\n\n\nIn \nBackBee\n content can be inherited from one another. The \nEventDispatcher\n respects this inheritance.\nIf an event is triggered for a subContent it will also be triggered for its parents. So \nclass content\n Events bubbles up in BackBee.", 
            "title": "Event Listener"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#the-event-listener-component", 
            "text": "Events  are a common and effective way to tie together loosely coupled components in an application.\nAn event is generally used to broadcast a change that has occured during a process. If a  component  is\ninterested in a particular event, it can  listen  to it. When this particular event is triggered, a  method ,\noften called  callback  or  handler  is executed. Events are convenient ways to share\ndata between components.\nIn  BackBee , events are triggered by an  EventDispatcher  and an  EventListener  is used to listen to them.", 
            "title": "The Event Listener component"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event", 
            "text": "Namespace: BackBee\\Event\\Event  The Backbee event class extend  sfEvent  and allows us to create a generic  Event  object.\nA generic event object has two properties:  target  and  args ;\nThe target property represents the target of the event. The  args  is an optional associated map.\nWhen the  args  property is provided, it's sent to the listeners.\nCustom Event can be created by extending the class  BackBee\\Event\\Event .  ?php\n$myHelloEvent = new Event($target, array( message = Hello BackBee );", 
            "title": "Event"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event-listener", 
            "text": "Namespace: BackBee\\Event\\EventListener  To listen to an event you must use the  addListener  method of the  EventDispatcher . addListener  takes three parameters. The first one is the name of the event that will be triggered, the second is an array whose first element\nis a class path and the second is a method. The last parameter is the priority of the event. Listener with higher priority will be triggered first.  $this- application- getEventDispatcher()- addListener(\"loading.event\", array(\"BackBee/Event/Listener/HelloListener\", \"sayHello\"));  Here, we register the listener  HelloListener  to be executed when the event  loading.event  is occured.       ?php\n\n        namespace BackBee\\Event\\Listener;\n        use BackBee\\Event\\Event;\n\n        class HelloListener {\n\n            public static sayHello (Event $event) {\n\n                $dispatcher = $event- getDispatcher();\n\n                if ($event- hasArguments( message )) {\n                    $message = $event- get( message );\n                    if ( null !== $dispatcher- getApplication()) {\n                        $dispatcher- getApplication()- getLogging()- notice($message);\n                    }\n                }\n            }\n        }\n\n    ?   Notice that the event object has access to the  application   via  the  EventDispacher  and that the  sayHello  is a  static  method.", 
            "title": "Event Listener"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event-dispatcher", 
            "text": "Namespace: BackBee\\Event\\EventListener  Events are  dispatched  or  triggered  by the  EventDispatcher  by using the method  triggerEvent \nThe sample bellow shows how to listen to an event.  To trigger an event, we must use the  EventDispatcher . It provides, among others, a  dispatch  method that takes two arguments. A name and an event object.  ?php\n    $this- application- getEventDispatcher()- dispatch( loading.event , $myHelloEvent);  When the  loading.event  is dispatched by the  EventDispatcher , all the registered listeners will be executed. In our example,\nthe static  sayHello  method of the  Backbee/Event/Listener/HelloListener  will be called.", 
            "title": "Event Dispatcher"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#events-from-class-content-component", 
            "text": "One of the main purpose of  Backbee  is to render contents. As we have seen, a\ncontent is defined in a  .yml  file. Content creation and content rendering go\nthrough many phases that  Backbee  exposes with events. By instance, an event is triggered\nwhen a content is created, before and after a content has been saved, when the rendering process\nis started, while the content is been rendered, after the renderer process and so on. These events\nallow us the act in different ways on the contents lifecycle and rendering process itself.  ClassContent events are similar to custom events. But, as they take place when the main application\nis dealing with a request, a common way to listen to them is to use an  event.yml  config file.\nWill try to local event file in the  repository/Config  folder. Bellow is an example of how to\nuse the file.      article.article.render:\n        listeners:\n            - [BackBee\\Event\\Listener\\ArticleListener, onRender]\n\n    social.facebook.prerender:\n        listeners:\n            - [BackBee\\Event\\Listener\\Socialistener, PrerenderFacebook]  events.yml  is a declarative way to add listeners to  ClassContentEvents  event. Under the hook,\nthis yaml file is parsed and the  EventDispatcher  is used to register the listeners.\nIn our example,   article.article.render  and  social.facebook.prerender  are events names.\nBy convention  BackBee  transforms ClassContent class path to event name. Let's take a look at our events files.  According to our  event.yml , the  article.article.render  event will be triggered when\nthe content  ClassContent/Article/Article.yml  is about the be rendered whereas\nthe 'social.facebook.prerender' will be triggered  before  the content  ClassContent/Social/Facebook.yml \nwas rendered. *.render   and  *.prerender  are events triggered by the  Renderer  object. Bellow is the list of\nall the Renderer events.   *.prerender  : is triggered  before  the content is being rendered;  *.render  : when the content is about to be rendered;  *.postrender  : after the render process.   However there is no strong difference between  render  and  postrender .  In BackBee all the contents are  Doctrine  entities. These doctrine events are also available for all the contents.   preremove  postremove  postupdate  preupdate  update  prepersist  postpersist  postload  onflush", 
            "title": "Events from Class Content Component"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#classcontent-listener", 
            "text": "To listen to a ClassContentEvent we have to create a  Listener  class. By default BackBee\nwill look for Listener in the repository/Config/Listener folder.       ?php\n        namespace BackBee\\Event\\Listener,\n        use BackBee\\Event\\Event;\n\n        class ArticleListener extends Event {\n\n            public static function onRender(Event $event){\n                /* The renderer object */\n                $renderer = $event- getEventArgs();\n\n                /* The eventDispatcher */\n                $eventDistacher = $event- getDispatcher();\n\n                /* the BackBee application */\n                $application = $eventDistacher- getApplication();\n\n                /* The article classcontent */\n                $content = $renderer- getObject();\n\n                /* Add a new parameter that will be available in the content template */\n                $renderer- assign('myParams',  my Param value );\n            }\n        }\n    ?", 
            "title": "ClassContent Listener"
        }, 
        {
            "location": "/developper-documentation/components/event_listener/#event-inheritance", 
            "text": "In  BackBee  content can be inherited from one another. The  EventDispatcher  respects this inheritance.\nIf an event is triggered for a subContent it will also be triggered for its parents. So  class content  Events bubbles up in BackBee.", 
            "title": "Event inheritance"
        }, 
        {
            "location": "/developper-documentation/components/routing/", 
            "text": "Components\n\n\nThe Routing component\n\n\nThis component is used in BackBee to map an HTTP request to a set of configuration variables.\nNote this component is an extension of \nSymfony Routing Component\n, so the official documentation is\nstill valid.\n\n\nHow the Routing component work ?\n\n\nTo set a basic routing system, you need at least to set and configure three objects:\n\n\n\n\nA \nBackBee\\Routing\\RouteCollection\n instance, which contains routes definitions (instance of \nBackBee\\Routing\\Route\n);\n\n\nA \nBackBee\\Routing\\RequestContext\n instance, which embed the current request;\n\n\nFinaly, a \nRequestMatcher\n instance, in charge of performs the mapping from request to a Route.\n\n\n\n\nIn BackBee CMS, all routes are declared in \nBackBee/Config/route.yml\n file, but obviously you can create your own routes in Standard\nEdition if you have frameworks needs outside the \"CMS\" context (backend bundles for instance).\n\n\nThe \nroute.yml\n is parsed by the Yaml component and BackBee create a \nRouteCollection\n instance, which is stored in Container as the\n\nrouting\n service (Symfony developpers should notice this behavior is a little bit different to the Symfony \nrouter\n service which is not available in BackBee).\n\n\nIn this file, you can find all the routes (and so on, paths) from the actual REST API used to communicate with the Javascript client when you are logged to BackBee Standard Edition.\n\n\nAlso, some routes are defined to handle some resources and finaly the most important route is the default route.\n\n\nLet's take an example:\n\n\n# Access all media\nbb.media.list:\n  pattern: /rest/{version}/medialist\n  defaults:\n    _action: medialistAction\n    _controller: BackBee\\Rest\\Controller\\MediaController # can be a service definition\n  requirements:\n    _method: GET\n\n\n\n\nA \nBackBee\\Route\n is defined by a pattern (mostly an url path) where we can use variables, have some mandatory defaults\n(binded to a Controller and an action) and may have some requirements.\n\n\nRouting component requirements\n\n\nThe \nrequirements\n property allow use to add requirements used by the \nRequestMatcher\n to map an url to a request.\n\n\nThis is an example of some available requirements:\n\n\n# this route is very difficult to match\nroute.name:\n  pattern: /route/{a}/{b}/{c}/difficult\n  defaults:\n    _action: fooAction\n    _controller: Baz\\BarController\n  requirements:\n    a: .+ # accept regex conditions\n    b: \\d+\n    _method:POST\n    condition: \ncontext.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\n # use the Symfony Expression Language component\n\n\n\n\nThe \ncondition\n requirement can use the Symfony Expression Language component and have access to:\n\n \ncontext\n: the instance of RequestContext;\n\n \nrequest\n: the instance of the actual Request;\n\n\nIf you are interested in this component, you can take a look to the official \nExpression Language\n documentation.", 
            "title": "Routing"
        }, 
        {
            "location": "/developper-documentation/components/routing/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/routing/#the-routing-component", 
            "text": "This component is used in BackBee to map an HTTP request to a set of configuration variables.\nNote this component is an extension of  Symfony Routing Component , so the official documentation is\nstill valid.", 
            "title": "The Routing component"
        }, 
        {
            "location": "/developper-documentation/components/routing/#how-the-routing-component-work", 
            "text": "To set a basic routing system, you need at least to set and configure three objects:   A  BackBee\\Routing\\RouteCollection  instance, which contains routes definitions (instance of  BackBee\\Routing\\Route );  A  BackBee\\Routing\\RequestContext  instance, which embed the current request;  Finaly, a  RequestMatcher  instance, in charge of performs the mapping from request to a Route.   In BackBee CMS, all routes are declared in  BackBee/Config/route.yml  file, but obviously you can create your own routes in Standard\nEdition if you have frameworks needs outside the \"CMS\" context (backend bundles for instance).  The  route.yml  is parsed by the Yaml component and BackBee create a  RouteCollection  instance, which is stored in Container as the routing  service (Symfony developpers should notice this behavior is a little bit different to the Symfony  router  service which is not available in BackBee).  In this file, you can find all the routes (and so on, paths) from the actual REST API used to communicate with the Javascript client when you are logged to BackBee Standard Edition.  Also, some routes are defined to handle some resources and finaly the most important route is the default route.  Let's take an example:  # Access all media\nbb.media.list:\n  pattern: /rest/{version}/medialist\n  defaults:\n    _action: medialistAction\n    _controller: BackBee\\Rest\\Controller\\MediaController # can be a service definition\n  requirements:\n    _method: GET  A  BackBee\\Route  is defined by a pattern (mostly an url path) where we can use variables, have some mandatory defaults\n(binded to a Controller and an action) and may have some requirements.", 
            "title": "How the Routing component work ?"
        }, 
        {
            "location": "/developper-documentation/components/routing/#routing-component-requirements", 
            "text": "The  requirements  property allow use to add requirements used by the  RequestMatcher  to map an url to a request.  This is an example of some available requirements:  # this route is very difficult to match\nroute.name:\n  pattern: /route/{a}/{b}/{c}/difficult\n  defaults:\n    _action: fooAction\n    _controller: Baz\\BarController\n  requirements:\n    a: .+ # accept regex conditions\n    b: \\d+\n    _method:POST\n    condition:  context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'  # use the Symfony Expression Language component  The  condition  requirement can use the Symfony Expression Language component and have access to:   context : the instance of RequestContext;   request : the instance of the actual Request;  If you are interested in this component, you can take a look to the official  Expression Language  documentation.", 
            "title": "Routing component requirements"
        }, 
        {
            "location": "/developper-documentation/components/security/", 
            "text": "Components\n\n\nThe Security component\n\n\nBackBee\n Security component is based on the Security Component of \nSymfony\n.\n\n\nIt provides a robust way to secure a web application. Here we will present some of the core concepts of this component : \nfirewall\n, \nFirewallMap\n, \nauthentication\n , \nauthorization\n, \nDecissionAccess\n,  \nVoter\n, \nSecurityContext\n.\n\n\nOverview of security mechanism\n\n\nThe main purpose of the security component is to deal with \nauthentication\n and \nauthorization\n.\n\n\nAuthentication is a way to grant access to a ressource. When a user is successfully authentified, authorization is a way to control access to a specific ressource.\n\n\nAuthentication is handled by what is called a \nfirewall\n. An application can have many secured areas, an admin area for instance.\n\n\nA secured area is determined by an \nurl\n. When an url that is part of a secured area is requested, behind the hook some registered callbacks are executed.\n\n\nThe \nFirewall\n archives this by listening to the \nsymfony\n \nkernel.request\n event triggered by the HttpKernel.\nA \nFirewallMap\n maps a \nrequest\n with the registered listeners then checks if the current request is under a secured area or is already secured.\n\n\nA \nFirewallMap\n Listener can authenticate a request, throws an \nAuthenticationException\n or do nothing. If one of these listeners throw an exception (meaning that the request is not authentificated), this exception can either be transformed into an \nAccessDeniedHttpException\n or used to initiate an authentication process by calling the \nFirewall\n entry point.\n\n\nAuthentication\n\n\nA firewall entry point, as it implements the \nauthenticationEntryPointInterface\n, must provided a \nstart\n method which takes two parameters: a request and the exception previously raised.\n\n\nstart\n must return a \nResponse\n object that can be a page showing a form for instance.\nIf one of the \nFirewallMap\n Listener can handle the request, it creates a \nToken\n object that holds a reference to the current user, its roles and its credentials.\nThe listener then uses an \nauthenticationProviderManager\n object to authenticate the \nToken\n. \nauthenticationProviderManager\n will authenticate the token if provided and return an \nauthenticated\n one if the user credential is valid.\n\n\nOtherwise an \nAuthenticationException\n is raised.\nEach \nToken\n uses a specific type of \nauthenticationProvider\n. An \nauthenticationProvider\n must implements the \nauthenticationProviderInterface\n and provides the two methods :  \nauthentificate\n which takes one paramater that must implements the \nTokenInterface\n and \nsupports\n which is used to check whether or not the given \ntoken\n is supported by the authentication provider .\n\n\nRegistered FirewallMap Listeners must implement the \nListenerInterface\n thus provided an \nhandle\n method that accept an \nGetRequestEvent\n object.\n\n\nAuthorization\n\n\nOnce a user is identified his roles or any other attributes or object of its \ntoken\n can be used to determine whether or not he has access to a resource.\n\n\nDecision manager\n\n\nAn \nAccessControlManager\n is used to make final access decisions based on \nVoter\n.\n\n\nA voter can decide to \nvote\n either for grant or deny access to a ressource. A voter can also abstain itself.\n\n\nBy default The \nAccessControllerManagers\n make his decision according to one these three strategies:\n\n\n\n\naffirmative\n (Access is granted if any voter votes for granting access)\n\n\nconsensus\n (Access is granted if there are more voters willing to granting access then otherwise\n\n\nunanimous\n (Access is granted if all voters vote for granting access)\n\n\n\n\nUnderstand voters\n\n\nA voter class must implements the \nVoterInterface\n which has 4 methods:\n\n\n\n\nsupportsAttribute($attribute)\n\n\nsupportsClass($class)\n\n\nvote(TokentInterface $token, $object, $attributes)\n\n\n\n\nsupportsAttribute\n is used to check if the voter supports some attributes of the token.\n\nsupportClass\n is user to check it the voter supports a specific class\n\nvote\n handle the vote strategy and must return of those class Constant :\n\n\n\n\nVoterInterface::ACCESS_GRANTED\n\n\nVoterInterface::ACCESS_ABSTAIN\n\n\nVoterInterface::ACCESS_DENIED\n\n\n\n\nBellow is list of Voter used in BackBee\n\n AccessVoter\n\n BBAclVoter\n\n BBRoleVoter\n\n SudoVoter\n\n\nBackBee SecurityContext and the ContextInterface\n\n\nAll the process of creating \nFirewall\n, \nFirewallMap\n, \nAuthenticationManager\n, \nAccessDecisionMananger\n and listeners is handled by the \nBackBee\\Security\\SecurityContext\n object.\n\n\nHowever the way of dealing with security Listerners is simplyfied by using a \nContext\n object.\nA security \nContext\n extends the abstract class \nBackBee\\Security\\Context\\BBAuthContext\n and defines the \nloadListeners\n method.\n\n\nLoadListeners\n accepts one parameter which is the security config that can be setted in \nrepository/Config/security.yml\n.\nA context can be used to instanciate new listener or to register new authentication provider to the \nSecuriryContext\n.\n\n\nBellow we show all the  security contexts provided by BackBee.\n\n\n\n\nAnonymousContext\n\n\nBBAuthContext\n\n\nLogoutContext\n\n\nRestfulContext\n\n\nStatelessContext\n\n\nUsernamePasswordContext\n\n\n\n\nAnonymousContext\n\n\nAnonymouseContext\n is used to identify anonymous user.\n\n\n\n\nauthentication provider\n : \nBackBee\\Security\\Authentication\\Provider\\AnonymousAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\AnonymousAuthenticationListener\n\n\nToken\n : \nBackBee\\Security\\Token\\AnonymousToken\n\n\n\n\nBBAuthContext\n\n\nBBAuthContext\n is used to authentify a user by using the BackBee User table.\n\n\n\n\nauthentication provider\n : \nBackBee\\Security\\Authentication\\Provider\\BBAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\AnonymousAuthenticationListener\n\n\nToken\n : \nBackBee\\Security\\Token\\BBUserToken\n\n\n\n\nLogoutContext\n\n\nLogoutContext\n handles user logout by removing all setted tokens.\n\n\n\n\nauthentication provider\n : \nnone\n\n\nToken\n : \nnone\n\n\nListener\n: \nBackBee\\Security\\Listeners\\LogoutListener\n\n\n\n\nRestfulContext\n\n\nRestfulContext\n is used to authentify rest user with a plublic key.\n\n\n\n\nauthentication provider\n: \nBackBee\\Security\\Listeners\\PublicKeyAuthenticationProvider\n\n\nListener\n : \nBackBee\\Security\\Listeners\\PublicKeyAuthenticationListener\n\n\nToken\n: \nBackBee\\Security\\Token\\BBUserToken\n\n\n\n\nStatelessContext\n\n\nIn stateless mode, authentication is asked for every requests. \nStatelessContext\n handles sessions\ncreation every time stateless mode is disabled.\n\n\n\n\nauthentication provider\n: \nnone\n\n\nListener\n: \nBackBee\\Security\\Listeners\\ContextListener\n\n\nToken\n: \nnone\n\n\n\n\nUsernamePasswordContext\n\n\nUsernamePasswordContext\nis used to authenticate user by using a login form.\n\n\n\n\nauthentication provider\n: \nBackBee\\Security\\Listeners\\Provider\\UserAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\UsernamePasswordAuthenticationListener\n\n\nToken\n: \nBackBee\\Security\\Token\\UsernamePasswordToken\n\n\n\n\nConfiguring Security with \nsecurity.yml\n\n\nSecurity configurations can be handled with a simple yml file. This file can be found in \nrepository/Config/security.yml\n.\n\n\nfirewalls:\n    bb_area:\n        pattern: ^/\n        requirements:\n            HTTP-X-Requested-With: XMLHttpRequest\n            HTTP-X-BB-METHOD: (JsonRpc|Upload)\n        provider: bb_user\n        bb_auth:\n            provider: bb_user\n            nonce_dir: security/nonces\n            lifetime: 1800\n            use_registry: true\n\nproviders:\n    bb_user:\n        entity:\n            class: BackBee\\Security\\User\n        secret: %secret_key%\n    public_key:\n        entity:\n            class: BackBee\\Security\\User\n\ncontexts:\n    BackBee\\Security\\Context: [StatelessContext, AnonymousContext, BBAuthContext, UsernamePasswordContext, LogoutContext, RestfulContext]\n\nencoders:\n    BackBee\\Security\\User:\n        class: Symfony\\Component\\Security\\Core\\Encoder\\MessageDigestPasswordEncoder\n        arguments:\n            algorithm: md5\n            encode_as_base64: false\n            iterations: 1\n\nacl:\n    connection: default", 
            "title": "Security"
        }, 
        {
            "location": "/developper-documentation/components/security/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developper-documentation/components/security/#the-security-component", 
            "text": "BackBee  Security component is based on the Security Component of  Symfony .  It provides a robust way to secure a web application. Here we will present some of the core concepts of this component :  firewall ,  FirewallMap ,  authentication  ,  authorization ,  DecissionAccess ,   Voter ,  SecurityContext .", 
            "title": "The Security component"
        }, 
        {
            "location": "/developper-documentation/components/security/#overview-of-security-mechanism", 
            "text": "The main purpose of the security component is to deal with  authentication  and  authorization .  Authentication is a way to grant access to a ressource. When a user is successfully authentified, authorization is a way to control access to a specific ressource.  Authentication is handled by what is called a  firewall . An application can have many secured areas, an admin area for instance.  A secured area is determined by an  url . When an url that is part of a secured area is requested, behind the hook some registered callbacks are executed.  The  Firewall  archives this by listening to the  symfony   kernel.request  event triggered by the HttpKernel.\nA  FirewallMap  maps a  request  with the registered listeners then checks if the current request is under a secured area or is already secured.  A  FirewallMap  Listener can authenticate a request, throws an  AuthenticationException  or do nothing. If one of these listeners throw an exception (meaning that the request is not authentificated), this exception can either be transformed into an  AccessDeniedHttpException  or used to initiate an authentication process by calling the  Firewall  entry point.", 
            "title": "Overview of security mechanism"
        }, 
        {
            "location": "/developper-documentation/components/security/#authentication", 
            "text": "A firewall entry point, as it implements the  authenticationEntryPointInterface , must provided a  start  method which takes two parameters: a request and the exception previously raised.  start  must return a  Response  object that can be a page showing a form for instance.\nIf one of the  FirewallMap  Listener can handle the request, it creates a  Token  object that holds a reference to the current user, its roles and its credentials.\nThe listener then uses an  authenticationProviderManager  object to authenticate the  Token .  authenticationProviderManager  will authenticate the token if provided and return an  authenticated  one if the user credential is valid.  Otherwise an  AuthenticationException  is raised.\nEach  Token  uses a specific type of  authenticationProvider . An  authenticationProvider  must implements the  authenticationProviderInterface  and provides the two methods :   authentificate  which takes one paramater that must implements the  TokenInterface  and  supports  which is used to check whether or not the given  token  is supported by the authentication provider .  Registered FirewallMap Listeners must implement the  ListenerInterface  thus provided an  handle  method that accept an  GetRequestEvent  object.", 
            "title": "Authentication"
        }, 
        {
            "location": "/developper-documentation/components/security/#authorization", 
            "text": "Once a user is identified his roles or any other attributes or object of its  token  can be used to determine whether or not he has access to a resource.  Decision manager  An  AccessControlManager  is used to make final access decisions based on  Voter .  A voter can decide to  vote  either for grant or deny access to a ressource. A voter can also abstain itself.  By default The  AccessControllerManagers  make his decision according to one these three strategies:   affirmative  (Access is granted if any voter votes for granting access)  consensus  (Access is granted if there are more voters willing to granting access then otherwise  unanimous  (Access is granted if all voters vote for granting access)   Understand voters  A voter class must implements the  VoterInterface  which has 4 methods:   supportsAttribute($attribute)  supportsClass($class)  vote(TokentInterface $token, $object, $attributes)   supportsAttribute  is used to check if the voter supports some attributes of the token. supportClass  is user to check it the voter supports a specific class vote  handle the vote strategy and must return of those class Constant :   VoterInterface::ACCESS_GRANTED  VoterInterface::ACCESS_ABSTAIN  VoterInterface::ACCESS_DENIED   Bellow is list of Voter used in BackBee  AccessVoter  BBAclVoter  BBRoleVoter  SudoVoter", 
            "title": "Authorization"
        }, 
        {
            "location": "/developper-documentation/components/security/#backbee-securitycontext-and-the-contextinterface", 
            "text": "All the process of creating  Firewall ,  FirewallMap ,  AuthenticationManager ,  AccessDecisionMananger  and listeners is handled by the  BackBee\\Security\\SecurityContext  object.  However the way of dealing with security Listerners is simplyfied by using a  Context  object.\nA security  Context  extends the abstract class  BackBee\\Security\\Context\\BBAuthContext  and defines the  loadListeners  method.  LoadListeners  accepts one parameter which is the security config that can be setted in  repository/Config/security.yml .\nA context can be used to instanciate new listener or to register new authentication provider to the  SecuriryContext .  Bellow we show all the  security contexts provided by BackBee.   AnonymousContext  BBAuthContext  LogoutContext  RestfulContext  StatelessContext  UsernamePasswordContext   AnonymousContext  AnonymouseContext  is used to identify anonymous user.   authentication provider  :  BackBee\\Security\\Authentication\\Provider\\AnonymousAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\AnonymousAuthenticationListener  Token  :  BackBee\\Security\\Token\\AnonymousToken   BBAuthContext  BBAuthContext  is used to authentify a user by using the BackBee User table.   authentication provider  :  BackBee\\Security\\Authentication\\Provider\\BBAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\AnonymousAuthenticationListener  Token  :  BackBee\\Security\\Token\\BBUserToken   LogoutContext  LogoutContext  handles user logout by removing all setted tokens.   authentication provider  :  none  Token  :  none  Listener :  BackBee\\Security\\Listeners\\LogoutListener   RestfulContext  RestfulContext  is used to authentify rest user with a plublic key.   authentication provider :  BackBee\\Security\\Listeners\\PublicKeyAuthenticationProvider  Listener  :  BackBee\\Security\\Listeners\\PublicKeyAuthenticationListener  Token :  BackBee\\Security\\Token\\BBUserToken   StatelessContext  In stateless mode, authentication is asked for every requests.  StatelessContext  handles sessions\ncreation every time stateless mode is disabled.   authentication provider :  none  Listener :  BackBee\\Security\\Listeners\\ContextListener  Token :  none   UsernamePasswordContext  UsernamePasswordContext is used to authenticate user by using a login form.   authentication provider :  BackBee\\Security\\Listeners\\Provider\\UserAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\UsernamePasswordAuthenticationListener  Token :  BackBee\\Security\\Token\\UsernamePasswordToken", 
            "title": "BackBee SecurityContext and the ContextInterface"
        }, 
        {
            "location": "/developper-documentation/components/security/#configuring-security-with-securityyml", 
            "text": "Security configurations can be handled with a simple yml file. This file can be found in  repository/Config/security.yml .  firewalls:\n    bb_area:\n        pattern: ^/\n        requirements:\n            HTTP-X-Requested-With: XMLHttpRequest\n            HTTP-X-BB-METHOD: (JsonRpc|Upload)\n        provider: bb_user\n        bb_auth:\n            provider: bb_user\n            nonce_dir: security/nonces\n            lifetime: 1800\n            use_registry: true\n\nproviders:\n    bb_user:\n        entity:\n            class: BackBee\\Security\\User\n        secret: %secret_key%\n    public_key:\n        entity:\n            class: BackBee\\Security\\User\n\ncontexts:\n    BackBee\\Security\\Context: [StatelessContext, AnonymousContext, BBAuthContext, UsernamePasswordContext, LogoutContext, RestfulContext]\n\nencoders:\n    BackBee\\Security\\User:\n        class: Symfony\\Component\\Security\\Core\\Encoder\\MessageDigestPasswordEncoder\n        arguments:\n            algorithm: md5\n            encode_as_base64: false\n            iterations: 1\n\nacl:\n    connection: default", 
            "title": "Configuring Security with security.yml"
        }
    ]
}